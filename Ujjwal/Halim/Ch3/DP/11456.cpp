#include <bits/stdc++.h>

using namespace std;

#ifdef LOCAL
#include "uj.h"
#endif

#define f first
#define s second

using vi = vector<int>;
using vvi = vector<vi>;
/*  O(n ^ 3) solution

int main() {
	int qq;
	scanf("%d", &qq);
	while (qq--) {
		int n;
		scanf("%d", &n);
		
		vi arr(n);
		for(int i = 0; i < n; ++i) {
			scanf("%d", &arr[i]);
		}
		
		vector<vvi> dp(n, vvi(n, vi(n, -1)));

		function < int (int, int , int) > Brute = [&] (int i, int j, int k) {
			if(i == n) return 0;
			int & ans = dp[i][j][k];
			if(ans != -1) return ans;

			if(arr[i] >= arr[j]) {
				ans = max(ans, Brute(i + 1, i, k) + 1);
			} else if(arr[i] <= arr[k]) {
				ans = max(ans, Brute(i + 1, j, i) + 1);
			}
			ans = max(ans, Brute(i + 1, j, k));
			return ans;
		};

		int answer = 0;
		for(int i = 0; i < n; ++i) {
			answer = max(answer, Brute(i + 1, i, i) + 1);
		}

		printf("%d\n", answer);
		
	}
	
	return 0;
}
 */

/*
	Initially I was trying to think that for any decreasing sequence like [a, b, c, d, e] if suppose we look at c
	then if we travel backward then we find increasing seq. and if we travel forward we find decreasing sequence.
	So I concluded increasing sequence ending with c from c - front and decreasing sequence starting with c from c - end 


	but this was not optimal as we were missing some cases in which both the thing may be in front front
	if you don't get these don't worry it was wrong idea just I am explaining to myself.

	The correct idea is that if we cosider longest increasing incerasing + longest decreasingg starting from ith element
	then this produces always right.

	Reason condier a b c d e f g h.
	Now suppose a c d f h is increasing
	also a b e g is decreasing

	then we can form the sequence like this h f d c a a b e g. As the mater of gurantee You can also produce the same 
	sequence via the operation that is given in the question. So this problem was all about longest decreasing sequence that
	can also be generated by the operation that is given, in the question i.e either appending in the front or back.
*/

int main() {
	int qq;
	scanf("%d", &qq);
	while (qq--) {
		int n;
		scanf("%d", &n);
		vi arr(n);
		for(int & x : arr) {
			scanf("%d", &x);
		}

		int dp1[n], dp2[n];	
		int answer = 0;
		for(int i = n - 1; i >= 0; --i) {
			dp1[i] = dp2[i] = 1;
			for(int j = i + 1; j < n; ++j) {
				if(arr[j] > arr[i]) {
					dp1[i] = max(dp1[i], dp1[j] + 1);
				}
				if(arr[j] < arr[i]) {
					dp2[i] = max(dp2[i], dp2[j] + 1);
				}
			}
			answer = max(answer, dp1[i] + dp2[i] - 1);
		}
		printf("%d\n", answer);
	}

	return 0;
}